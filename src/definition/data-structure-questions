Please answer the below Data Structure Questions:

why do we need data structure?
A.  Data structure is a particular way of storing and organizing information in a computer so that it can be retrieved and used
    most productively. we need data structure for the following reasons:
    =>  Data structures are used in almost every program or software system.
    =>  Specific data structures are essential ingredients of many efficient algorithms, and make possible the management of huge
        amounts of data, such as large integrated collection of databases.
    =>  Some programming languages emphasize data structures, rather than algorithms, as the key organizing factor in software design.

What are the various operations that can be performed on different Data Structures?
A.  Following operations can be performed on the data structures:
    Inserting: It is used to add a new data item in the given collection of data items.
    Deleting: It is used to delete an existing data item from the given collection of data items.
    Searching: It is used to find out the location of the data item if it exists in the given collection of data items.
    Sorting: It is used to arrange the data items in some order i.e. in ascending or descending order in case of numerical data and
    in dictionary order in case of alphanumeric data.
    Traversing: It is used to access each data item exactly once so that it can be processed.
    Merging: It is used to combine the data items of two sorted files into single file in the sorted form.

List out the areas in which data structures are applied extensively?
A. Compiler Design,

   => Operating System
   => Database Management System
   => Statistical analysis package
   => Numerical Analysis
   => Graphics
   => Artificial Intelligence
   => Simulation

what is an Array?
A.  Array is a kind of data structure that can store a fixed-size sequential collection of elements of the same type.
    A specific element in an array is accessed by an index.

what is the difference between the Array and ArrayList?
A.  => An array is basic functionality provided by Java. ArrayList is part of collection framework in Java.
    => Array is a fixed size data structure while ArrayList is array which can dynamically grow and shrink.
    => Array can contain both primitive data types as well as objects of a class depending on the definition of the array.
       However, ArrayList only supports object entries, not the primitive data types.

what is LinkedList?
A.  A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. so, a
    linked list consists of nodes where each node contains a data field and a reference(link) to the next node in the list.

How is an Array different from Linked List?
A.  Array is a collection of elements having same data type with common name.
    Linked list is an ordered collection of elements which are connected by links/pointers.

    In array, elements can be accessed using index/subscript value, i.e. elements can be randomly accessed like arr[0], arr[3], etc.
    So array provides fast and random access.
    In linked list, elements can’t be accessed randomly but can be accessed only sequentially and accessing element takes 0(n) time.

    In array, elements are stored in consecutive manner in memory.
    In linked list, elements can be stored at any available place as address of node is stored in previous node.

    Insertion & deletion takes more time in array as elements are stored in consecutive memory locations.
    Insertion & deletion are fast & easy in linked list as only value of pointer is needed to change.

    In array, memory is allocated at compile time i.e. Static Memory Allocation.
    In linked list, memory is allocated at run time i.e. Dynamic Memory Allocation.

    In array, each element is independent, no connection with previous element or with its location.
    In Linked list, location or address of elements is stored in the link part of previous element/node.

    Array can be single dimensional, two dimension or multidimensional.
    Linked list can be singly, doubly or circular linked list.

what is queue?
A.  A queue is a linear data structure or an ordered collection of items where the addition of new items happens at one end, called the “rear,”
    and the removal of existing items occurs at the other end, commonly called the “front.” his ordering principle is called FIFO,
    first-in first-out. It is also known as “first-come first-served.”

what is stack?
A.  A stack (sometimes called a “push-down stack”) is an ordered collection of items where the addition of new items and the removal of
    existing items always takes place at the same end. This end is commonly referred to as the “top.” The end opposite the top is known
    as the “base.” The ordering principle is called LIFO, last-in first-out. It provides an ordering based on length of time.
    in the collection.

what is FIFO and LIFO?
A.  FIFO: First In First Out => Queue follows FIFO methodology where the data item stored first will be accessed first.
    LIFO: Last In First Out => Stack follows LIFO methodology where the data item stored last will be accessed first.

what is the order of complexity?
A.   Generally, an algorithm has an asymptotic computational complexity. Assuming the input is of size N, we can say that the algorithm
     will finish at O(N), O(N^2), O(N^3), O(N*log(N)) etc. This means that it is a certain mathematical expression of the size of the input,
     and the algorithm finishes between two factors of it. The smaller the order of complexity of the program's underlying algorithm,
     the faster it will run and the better it will scale as the input gets larger. Thus, we should often seek more efficient algorithms in order
     to reduce the order of complexity.

what is the best case to search an element from an array?
A.  Sorting Algorithm and Binary Search.

what is the worst case to search an element from an array?
A.  For an unsorted array case, we have to search element by element until the element is found or array is completely
    traversed. Element can be at 1st position, the last position or in between. The worst case arises when
    the element is at last position or not in the array because, in that case, we need to traverse the whole array with given n number
    of repetitions over loop. So, the worst case time complexity would be O(n).

what is tree in data structure?
A.  Tree are well known as a non-linear Data Structure. It doesn’t store data in a linear way. It organizes data in a hierarchical way.

what is graph in data structure?
A.  A Graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices and the
    edges are lines or arcs that connect any two nodes in the graph.

what is the difference between the HashTable and HashMap?
A.  => HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization
       code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
    => HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
    => HashMap is generally preferred over HashTable if thread synchronization is not needed

What are the major data structures used in the following areas : RDBMS, Network data model and Hierarchical data model.
A.  => RDBMS - Array
    => Network data model - Graph
    => Hierarchical data model - Trees

How HashMap works in java?
A. HashMap in Java works on hashing principle. It is a data structure which allows us to store object and retrieve it in constant
   time O(1) provided we know the key. In hashing, hash functions are used to link key and value in HashMap. Objects are stored by
   calling put(key, value) method of HashMap and retrieved by calling get(key) method.

What is ArrayIndexOutOfBoundsException in java? When it occurs?
A.  ArrayIndexOutOfBoundsException is a runtime exception.

    java.lang.ArrayIndexOutOfBoundsException occurs when we try to access an element of an array, with an index that is negative or
    more than the size of array itself.

What are the different ways of copying an array into another array?
A.  Manually, Arrays.copyOf(), System.arraycopy(), Object.clone()

What is difference between an array and a linked list?
A.  See answer above....

What is DFS and BFS?
A. A Tree is typically traversed in two ways, such as
   => BFS: Breadth First Search/Traversal (Or Level Order Traversal)
   => DFS: Depth First Search/Traversals

What is Recursion?
A.  The process in which a function calls itself directly or indirectly is called recursion and the corresponding function
    is called as recursive function.

What are linear and non linear data Structures?
A.  Linear: The data items are arranged in an orderly manner where the elements are attached adjacently.
    Example: Array, queue, stack, linked list, etc.

    Non-Linear: It arranges the data in a sorted order and there exists a relationship between the data elements.
    Example: Tree and graph.

What is Big-(O)-notation?
A.  Big O notation is used in Computer Science to describe the performance or complexity of an algorithm. Big O specifically
    describes the worst-case scenario, and can be used to describe the execution time required or the space used (e.g. in memory
    or on disk) by an algorithm.

Outlined different kind of sorting algorithm with time complexity?
A.
   1. Selection sort: It is an in-place comparison sort.Selection sort is noted for its simplicity, and also has performance advantages over more complicated algorithms in certain situations.
      Worst case performance: O(n2)
      Best case performance: O(n2)
      Average case performance: O(n2)
      Worst case space complexity: O(n) total, O(1) auxiliary

   2. Insertion sort: It is a comparison sort in which the sorted array (or list) is built one entry at a time. It is much less
      efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.
      Worst case performance: O(n2)
      Best case performance: O(n)
      Average case performance: O(n2)
      Worst case space complexity: O(n) total, O(1) auxiliary

   3. Bubble sort: It is a comparison algorithm. It works by repeatedly stepping through the list to be sorted, comparing each
      pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are
      needed, which indicates that the list is sorted.
      Worst case performance: O(n2)
      Best case performance: O(n)
      Average case performance: O(n2)
      Worst case space complexity: O(n) total, O(1) auxiliary
      Bubble sort is not a practical sorting algorithm when n is large.

   4.  Merge sort: It is an O(n log n) comparison-based sorting algorithm.
       Worst case performance: O(n log n)
       Best case performance: O(n log n) typical
       Average case performance: O(n log n)
       Worst case space complexity: O(n) total, O(n) auxiliary

   5.  Quick sort: It is similar to merge sort in many ways. It divides the elements to be sorted into two groups, sorts the two groups by recursive
       calls, and combines the two sorted groups into a single array of sorted values. The choice of a good pivot element is critical to the efficiency
       of the quicksort algorithm. If we can ensure that the pivot element is near the median of the array values, then quicksort is very efficient.
       on average, makes O(n log n) comparisons to sort n items, in the worst case, it makes O(n2) comparisons.


Draw a table with time complexity in which it will summarize all the data structure feature's advantages and disadvantages.
  a)In terms of Accessing element.
  b)In terms of Inserting element.
  c)In terms of Searching element.
  d)In terms of Removing element.


A. Common Data Structure Operations as below:

  Data Structure	                                  Time Complexity
                     (Average)	                                       (Worst)
                      Access	    Search	    Insertion	Deletion	Access	    Search	    Insertion	Deletion
  Array	               T(1)	       T(n)	          T(n)	    T(n)	    O(1)	    O(n)	    O(n)	    O(n)
  Stack	               T(n)	       T(n)	          T(1)	    T(1)	    O(n)	    O(n)	    O(1)	    O(1)
  Queue	               T(n)	       T(n)	          T(1)	    T(1)	    O(n)	    O(n)	    O(1)	    O(1)
  Singly-Linked List   T(n)	       T(n)	          T(1)	    T(1)	    O(n)	    O(n)	    O(1)	    O(1)
  Doubly-Linked List   T(n)	       T(n)	          T(1)	    T(1)	    O(n)	    O(n)	    O(1)	    O(1)
  Skip List	           T(log(n))   T(log(n))	  T(log(n))	T(log(n))	O(n)	    O(n)	    O(n)	    O(n)
  Hash Table	       N/A	       T(1)	          T(1)	    T(1)	    N/A	        O(n)	    O(n)	    O(n)
  Binary Search Tree   T(log(n))   T(log(n))	  T(log(n))	T(log(n))	O(n)	    O(n)	    O(n)	    O(n)
  Cartesian Tree	   N/A	       T(log(n))	  T(log(n))	T(log(n))	N/A	        O(n)	    O(n)	    O(n)
  B-Tree	           T(log(n))   T(log(n))	  T(log(n))	T(log(n))	O(log(n))	O(log(n))	O(log(n))	O(log(n))
  Red-Black Tree	   T(log(n))   T(log(n))	  T(log(n))	T(log(n))	O(log(n))	O(log(n))	O(log(n))	O(log(n))
  Splay Tree	       N/A	       T(log(n))	  T(log(n))	T(log(n))	N/A	        O(log(n))	O(log(n))	O(log(n))
  AVL Tree	           T(log(n))   T(log(n))	  T(log(n))	T(log(n))	O(log(n))	O(log(n))	O(log(n))	O(log(n))
  KD Tree 	           T(log(n))   T(log(n))      T(log(n))	T(log(n))	O(n)	    O(n)	    O(n)	    O(n)
